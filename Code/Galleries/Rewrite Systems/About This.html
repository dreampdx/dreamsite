<html>
	<head>
		<title> Palace | Computation </title>
		<link rel="stylesheet" type="text/css" href="grid_styles.css">
		<link rel="stylesheet" type="text/css" href="../../../style_page.css">
        <link href="https://fonts.googleapis.com/css?family=Nunito|Ubuntu&display=swap" rel="stylesheet">
		<script src="CGL.js"></script>
	</head>
	<body>
		<header>
			<h1> <a href="..\..\..\index.html"> Palace</a> /<a href="..\..\Gallery.html">Computation</a> /Rewrite Systems</h1>
		</header>
		
		<aside>
            <ul class="nav-area">
                <li><h3>Topics:</h3></li>
                <li class="list-effect-1"><a href="Laboratory.html">To Laboratory</a></li>
				<li class="list-effect-1"><a href="../../Gallery.html">Back to Gallery</a></li>
			</ul>
		</aside>
		
		<content>
			
			<p class="chris"> Firstly, I began learning about rewrite systems from Richard Southwell's website, which I found through his sequence of YouTube videos regarding category theory. His thoughts on rewrite systems are https://sites.google.com/site/richardsouthwell254/home/rewrite-systems,  </p>

			<p class="chris"> Rewrite systems take a certain set of rules and use them to rewrite strings iteratively. These systems are then represented as these strings stacked atop one another, going down for as many iterations as is desired. </p>

			<p class="chris"> Certain rewrite systems have been found which directly emulate a <a href="https://en.wikipedia.org/wiki/Wolfram's_2-state_3-symbol_Turing_machine"> universal turing machine </a>, making these systems computationally universal. Steven Wolfram goes further in his claim for the Principal of Computational Equivalence, which claims that "if one sees behavior that is not obviously simple, the behavior will correspond to a computation that is in a sense 'maximally sophisticated'".</p class="chris">

			<p class="chris"> The implementation of rewrite systems that I am planning will have four rules (of arbitrary length) with five colors to choose from. I am currently interested in these systems for the artistic content produced by them, and for the challenge of creating the implementation. Outstanding problems regarding these systems relate to generalizing them for computation, or whether rules can be produced under certain constraints that still generate arbitrary complexity. </p class="chris">

			<p class="chris"> I then found more on rewrite systems on, surprise surprise, wikipedia. </p>

			<p class="wikip"> A rewriting system can be expressed as a directed graph in which nodes represent expressions and edges represent rewrites. So, for example, if the expression a can be rewritten into b, then we say that b is a reduct of a (alternatively, a reduces to b, or a is an expansion of b). This is represented using arrow notation; a â†’ b indicates that a reduces to b. Intuitively, this means that the corresponding graph has a directed edge from a to b. </p>

			<p class="chris"> This is cool, this takes what I was understanding through visual means to a more formal graphical understanding. So, if a and b are expressions, and one can take a to b through a series of rewrites, then this is similar to the beta-reduction in lambda calculus, or the computational step in functional programming. There comes up this diagram that I've been really enjoying seeing all over the place, this completing square, in this case demonstrating that if there exist reductions from a to any b and from a to any c, thus forming one side of the square, and if there also exist reductions from every b to d and every c to d, thus completing the square, then a is deemed confluent.</p>

			<p class="chris"> This idea is the basis of the Church-Rosser theorem, which implies that, because lambda expressions are confluent by beta-reduction, any path can be taken when the lambda expression is evaluated, because by confluence, any rewrite from a -> b would still have a path to the termination of the rewrite. This is super cool. </p>
			
		</content>
	</body>
</html>
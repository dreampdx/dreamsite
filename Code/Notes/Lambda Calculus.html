<html>
	<head>
		<title> Palace | Computation</title>
		<link rel="stylesheet" type="text/css" href="../../style_page.css">
	</head>
	<body>
		<header>
			<h1> <a href="..\..\index.html"> Palace</a> /<a href="..\Gallery.html">Computation</a> /Discussion</h1>
		</header>
		
		<aside>
            <ul class="nav-area">
                <li><h3>Topics:</h3></li>
                <li class="list-effect-1"><a href="../../Art/Gallery.html">Art</a></li>
                <li class="list-effect-1"><a href="../../Computation/Gallery.html">Computation</a></li>
                <li class="list-effect-1"><a href="../../Language/Gallery.html">Language</a></li>
                <li class="list-effect-1"><a href="../../Mathematics/Gallery.html">Mathematics</a></li>
                <li class="list-effect-1"><a href="../../Music/Gallery.html">Music</a></li>
                <li class="list-effect-1"><a href="../../Other/Gallery.html">Other</a></li>
            </ul>
			<hr>
			<ul class="nav-area-notes">
				<li><h3>Notes:</h3></li>
				<li class="list-effect-1"><a href="Notes/Cellular Automata.html">Cellular Automata</a></li>
				<li class="list-effect-1"><a href="Notes/Chu Spaces.html">Chu Spaces</a></li>
				<li class="list-effect-1"><a href="Notes/Lambda Calculus.html">Lambda Calculus</a></li>
			</ul>
        </aside>
		
		<content>
			
			<p class="boxed"> Lambda Calculus is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution. It is a universal model of computation that can be used to simulate any Turing machine. It was introduced by the mathematician Alonzo Church in the 1930s as part of his research into the foundations of mathematics. </p>

			<p class="chris"> This topic came up in my functional programming course I just began, essentially introduced as the foundation of functional programming, and after reading this introduction that makes complete sense to me. This seems like computation through expression simplification, as opposed to computation through sequential instruction execution, as it is in imperitive programming. </p>

			<p class="chris"> As with functional programming, the ruleset seems deceptively simple... </p>

			<p class="boxed"> Lambda calculus consists of constructing lambda terms and performing reduction operations on them. In the simplest form of lambda calculus, terms are built using only the following rules: </p>

			<p class="boxed">
				<table>
					<tr>
						<th>Syntax</th>
						<th>Name</th>
						<th>Description</th>
					</tr>
					<tr>
						<td>x</td>
						<td>Variable</td>
						<td>A character or string representing a parameter or mathematical/logical value.</td>
					</tr>
					<tr>
						<td>(^x.M)</td>
						<td>Abstraction</td>
						<td>Function definition (M is a lambda term). The variable x becomes bound in the expression</td>
					</tr>
					<tr>
						<td>(M N)</td>
						<td>Application</td>
						<td>Applying a function to an argument. M and N are lambda terms.</td>
					</tr>
				</table>
			</p>

			<p class="chris">So, there exist variables, function definitions, and function applications. This is essentially exactly the same as in Haskell, where there exist variables, function type declarations, and function definitions. And that's it! The craziness comes from the additions of operations. In Haskell this takes the form of what operations one would normally expect in a programming language (arithmetic, integer and boolean), as well as arithmetic involving lists and strings. In lambda calculus, it seems that there exist some amount operations to include as well, namely the alpha-conversion, and beta-reduction, which rename bound variables, and replace bound variables with argument expressions in bodies of abstractions, respectively.</p>

			<p class="chris">An exciting pull regarding beta-reduction...</p>

			<p class="boxed">The β-reduction rule states that an application of the form (^x.t)s reduces to the term t[x:=s]. The notation (^x.t)s --> t[x:=s] is used to indicate that (^x.t)s β-reduces to t[x:=s]. For example, for every s, (^x.x)s --> x[x:=s]=s. This demonstrates that ^x.x really is the identity. Similarly, (^x.y)s --> y[x:=s]=y, which demonstrates that ^x.y is a constant function.</p>

			<p class="boxed"> The lambda calculus may be seen as an idealised version of a functional programming language, like Haskell or Standard ML. Under this view, β-reduction corresponds to a computational step. This step can be repeated by additional β-reductions until there are no more applications left to reduce</p>

			<p class="chris"> This is super cool, this is the step then in lambda calculus that corresponds to the rewriting of one part of the expression with another, the robot marker and eraser to which my functional programming professor related functional programming evaluation. This is the step, this is the action that performs the computation! </p>

			<p class="chris"> I have now skipped down into the wikipedia article, to view a section entiteled "Encoding Datatypes". This section deals with how lambda calculus can be used to express formal mathematical/computational constructs, such as booleans, arithemetic, and data structures. I will briefly summarize what I got from the following many paragraphs of dense information:</p>

			<p class="chris"> The natural numbers can be derived in lambda calculus by composing the identity function together n times, where n is the desired natural number. In this formalization, 0 would correspond to a single application of the identity function. These are called Church Numbers. </p>
				
			<p class="chris"> Now, so armed with numbers, we then do things with them. Succession is derived, a function that adds one to some church number, as is addition and multiplication. Logic is derived too, as functions that implement a constant function (true) and identity function (false). Thus, false is defined as the Church Numeral zero. Which is cool. </p>

			<p class="chris"> Functional recursion, named constants, and other programming practices are derived too.</p>

		</content>
	</body>
</html>